## 用Java实现设计模式
### 资料
书名：《图解设计模式》 作者: 结城浩 译者: 杨文轩
### 第1部分 适应设计模式
Iterator模式
* 定义：将循环变量i的作用抽象化，通用化后形成的设计模式
* 形式：为某个类创建迭代器，使其能使用迭代器遍历
* 作用：使遍历和具体实现分离，这样后面只修改实现迭代器的逻辑即可，对于遍历则不用修改

Adapter模式：类适配器，委托适配器
* 定义：填补“现有的程序”和“所需的程序”之间差异的设计模式
* 形式：经过适配器，将被适配类转化成目标类，实际上目标类和被适配类的部分功能应该是相同的
* 作用：把类当作组件复用时；不改变现有代码使现有代码适配新的接口；更容易维护新旧版本

### 第2部分 交给子类
TemplateMethod模式
* 定义：在父类中定义处理流程的框架，在子类中实现具体处理的设计模式
* 形式：父类定义处理流程的方法，而且被final修饰，保证不被子类修改
* 作用：逻辑处理通用化

FactoryMethod模式
* 定义：将TemplateMethod模式用于生成实例，就成了工厂方法模式
* 形式：工厂方法生成产品实例，而不再通过new产品的方式
* 作用：框架与具体加工解耦，而且在工厂中可以做一些创建实例时就必须做的事，比如记录实例信息

### 第3部分 生成实例
Singleton模式
* 定义：确保只生成一个实例的设计模式
* 形式：实例字段使用private，static修饰；构造方法使用private修饰；获取实例的方法使用static修饰，多线程环境下可用synchronized修饰
* 作用：防止实例之间相互影响

Prototype模式
* 定义：通过复制实例创建实例的设计模式
* 形式：使用者使用复制实例的方法生成新的实例；复制实例使用和类名对应的名称
* 作用：对象种类繁多，无法整合到一个类中；难以根据类生成实例；解耦框架与生成的实例

Builder模式
* 定义：组装复杂结构的实例的设计模式
* 形式：建造者定义抽象方法，具体建造者则实现这些方法；监工使用建造者建造实例；使用者则通过建工建造实例
* 作用：使得具体的建造者插件化，而监工和建造者则可以复用。

Abstract Factory模式
* 定义：将抽象零件组装成抽象产品，不关心零件具体实现的设计模式
* 形式：抽象工厂用来组装抽象零件，抽象产品，具体如何组装则交给具体的工厂类，而产品，零件具体怎么产生的交给具体的产品，零件类
* 作用：易于增加具体的工厂；难以增加新的零件

### 第4部分 分开考虑
Bridge模式
* 定义：将类的功能层次结构和类的实现层次结构连接起来的模式
* 形式：实现层次结构的顶级抽象类作为功能层次结构的顶级类中的成员(委托)，功能层次结构中的类实现功能实际上都是调用实现层次结构的类来实现功能的
* 作用：分离类的功能层次结构和类的实现层次结构

Strategy模式
* 定义：能够整体的替换算法，能让我们轻松地以不同的算法去解决一个问题的设计模式
* 形式：接口或者抽象类的策略类，被使用委托的方式使用算法。
* 作用：方便的替换算法，可以用旧算法验证新算法，可以根据不同的场景使用不同的算发。

### 第5部分 一致性
Composite模式
* 定义：使容器和内容具有一致性，创造出递归结构的设计模式
* 形式：某个类(接口)Class A的成员变量的类型是类(接口)Class A
* 作用：容器和内容具有一致性(相同接口)，比如文件系统的目录(文件夹和文件)

Decorator模式
* 定义：不断的为对象添加装饰器的设计模式
* 形式：抽象装饰器是抽象被装饰物的派生，且抽象装饰器包含父类实例，具体装饰由具体装饰器类实现
* 作用：装饰边框与被装饰物具有一致性(相同接口)；在不改变被装饰物的前提下增加功能；动态增加功能

### 第6部分 访问数据结构
Visitor模式
* 定义：分离数据结构和对数据的处理的设计模式
* 形式：对数据的处理交给外部类实现，外部处理的实现还可以调用数据结构类本身的方法(看需求)，有些像python中的高阶函数
* 作用：分离数据结构和对数据的处理满足开闭原则，使得数据结构类有高可复用性；能方便地增加对数据的处理操作，因为不会对数据结构类造成影响
* 缺点：难以增加具体的Element角色，增加一个就要在Visitor中实现一个对应方法；Visitor工作需要Element角色公开足够多的信息，公开少了不能工作，公开多了很难对数据结构改良

Chain of Responsibility模式
* 定义：将多个对象组成责任链，按照责任链的顺序找出哪个对象负责处理的设计模式。
* 形式：处理请求的类中包含下一个处理请求的类，如果自己不能处理，就抛给下一个，都不能处理就声明不能处理
* 作用：弱化发出请求的角色和处理请求的角色之间的关系；可以动态的改变责任链。
* 缺点：延迟；如果责任链前面的类的处理范围比后面的类的处理范围大，那后面的就用不到了，责任链的顺序也要考虑好吧

### 第7部分 简单化
Facade模式
* 定义：将类之间的调用顺序流程化，形成一个简单的高层的接口(API)的设计模式。
* 形式：提供一高层接口(API),将复杂的类之间的调用顺序封装在里面。
* 作用：减少接口(API)的数量，弱化程序与外部的关联，容易使包作为组件复用。

Mediator模式
* 定义：同事向仲裁者报告，仲裁者向同事下达指示，同事之间不沟通的设计模式。(感觉每一个“同事”都是老板派来的卧底，卧底不知道其它卧底)
* 形式：仲裁者和同事相互委托，一切决定交给仲裁者处理。
* 作用：集中难以处理的分散流程，易于开发；同事类变多之后交互很复杂，仲裁者可以减少交互线路。
* 缺点：仲裁者难以复用。

### 第8部分 管理状态
Observer模式
* 定义：当观察对象的状态发生变化时，会通知观察者进行相关处理的设计模式。
* 形式：观察对象中存在观察者成员(委托)，当观察对象的状态发生变化时，调用方法通知观察者。
* 作用：统一状态改变时的处理形式(统一接口)

Memento模式
* 定义：通过引入表示实例状态的角色，可以保存和恢复实例时有效地防止对象的封装性遭到破坏。
* 形式：再处理流程中，当角色状态发生变化，则调用角色方法生成用于保存状态的实例，保存当前状态。
* 作用：处理流程和角色分离，提高角色复用性；用实例表示状态，防止对象的封装性遭到破坏。

State模式
* 定义：用类表示状态(如条件判断中的分支)的设计模式。
* 形式：在Context角色中持有State角色，并且有切换State的处理，有些处理可以委托给State处理
* 作用：不会产生条件矛盾；易于增加新的状态。

### 第9部分 避免浪费
FlyWeight模式
* 定义：通过共享实例减少内存使用的设计模式
* 形式：对于不会改变实例状态的情况，共享实例使用，而不是每次用都创建新的实例。
* 作用：减少内存使用量；减少new生成实例的次数提高运行速度；

Proxy模式
* 定义：让代理人完成工作，除非代理人无法完成，才由本人完成的设计模式。
* 形式：对本人的方法调用大部分交给代理人完成，当代理人无法完成会创建本人实例去完成。
* 作用：避免了在不必要时生成某些耗时的实例，提升程序性能；对于调用者来说代理时透明的；划分代理人和本人使得两个角色称为独立组件，利于复用和修改。

### 第10部分 用类来实现
Command模式
* 定义：用对象表示“命令”来保存命令历史记录和重复执行命令的设计模式。
* 形式：用对象表示命令，命令的执行委托给其它类实现
* 作用：分离命令与执行命令的过程，命令可以作为组件复用

Interpreter模式
* 定义：使用“迷你语言”写程序解决问题，而java则实现“迷你语言”的解释器的设计模式。
* 形式：用java实现一个语法树，负责解释“迷你语言”。
* 作用：当修改解决问题的程序时可以只修改“迷你语言”层，无需修改java程序。
* 例子：正则表达式，检索表达式，批处理语言
