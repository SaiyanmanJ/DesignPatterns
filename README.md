## 用Java实现设计模式
### 资料
书名：《图解设计模式》 作者: 结城浩 译者: 杨文轩
### 第1部分 适应设计模式
Iterator模式
* 定义：将循环变量i的作用抽象化，通用化后形成的设计模式
* 形式：为某个类创建迭代器，使其能使用迭代器遍历
* 作用：使遍历和具体实现分离，这样后面只修改实现迭代器的逻辑即可，对于遍历则不用修改

Adapter模式：类适配器，委托适配器
* 定义：填补“现有的程序”和“所需的程序”之间差异的设计模式
* 形式：经过适配器，将被适配类转化成目标类，实际上目标类和被适配类的部分功能应该是相同的
* 作用：把类当作组件复用时；不改变现有代码使现有代码适配新的接口；更容易维护新旧版本

### 第2部分 交给子类
TemplateMethod模式
* 定义：在父类中定义处理流程的框架，在子类中实现具体处理的设计模式
* 形式：父类定义处理流程的方法，而且被final修饰，保证不被子类修改
* 作用：逻辑处理通用化

FactoryMethod模式
* 定义：将TemplateMethod模式用于生成实例，就成了工厂方法模式
* 形式：工厂方法生成产品实例，而不再通过new产品的方式
* 作用：框架与具体加工解耦，而且在工厂中可以做一些创建实例时就必须做的事，比如记录实例信息

### 第3部分 生成实例
Singleton模式
* 定义：确保只生成一个实例的设计模式
* 形式：实例字段使用private，static修饰；构造方法使用private修饰；获取实例的方法使用static修饰，多线程环境下可用synchronized修饰
* 作用：防止实例之间相互影响

Prototype模式
* 定义：通过复制实例创建实例的设计模式
* 形式：使用者使用复制实例的方法生成新的实例；复制实例使用和类名对应的名称
* 作用：对象种类繁多，无法整合到一个类中；难以根据类生成实例；解耦框架与生成的实例

Builder模式
* 定义：组装复杂结构的实例的设计模式
* 形式：建造者定义抽象方法，具体建造者则实现这些方法；监工使用建造者建造实例；使用者则通过建工建造实例
* 作用：使得具体的建造者插件化，而监工和建造者则可以复用。

Abstract Factory模式(没写具体实现类)
* 定义：将抽象零件组装成抽象产品，不关心零件具体实现的设计模式
* 形式：抽象工厂用来组装抽象零件，抽象产品，具体如何组装则交给具体的工厂类，而产品，零件具体怎么产生的交给具体的产品，零件类
* 作用：易于增加具体的工厂；难以增加新的零件

### 第4部分 分开考虑
Bridge模式
* 定义：将类的功能层次结构和类的实现层次结构连接起来的模式
* 形式：实现层次结构的顶级抽象类作为功能层次结构的顶级类中的成员(委托)，功能层次结构中的类实现功能实际上都是调用实现层次结构的类来实现功能的
* 作用：分离类的功能层次结构和类的实现层次结构

Strategy模式
* 定义：能够整体的替换算法，能让我们轻松地以不同的算法去解决一个问题的设计模式
* 形式：接口或者抽象类的策略类，被使用委托的方式使用算法。
* 作用：方便的替换算法，可以用旧算法验证新算法，可以根据不同的场景使用不同的算发。

### 第5部分 一致性
Composite模式
* 定义：使容器和内容具有一致性，创造出递归结构的设计模式
* 形式：某个类(接口)Class A的成员变量的类型是类(接口)Class A
* 作用：容器和内容具有一致性(相同接口)，比如文件系统的目录(文件夹和文件)

Decorator模式
* 定义：不断的为对象添加装饰器的设计模式
* 形式：抽象装饰器是抽象被装饰物的派生，且抽象装饰器包含父类实例，具体装饰由具体装饰器类实现
* 作用：装饰边框与被装饰物具有一致性(相同接口)；在不改变被装饰物的前提下增加功能；动态增加功能

### 第6部分 访问数据结构
Visitor模式 
* 定义：分离数据结构和对数据的处理的设计模式
* 形式：对数据的处理交给外部类实现，外部处理的实现还可以调用数据结构类本身的方法(看需求)，有些像python中的高阶函数
* 作用：分离数据结构和对数据的处理满足开闭原则，使得数据结构类有高可复用性；能方便地增加对数据的处理操作，因为不会对数据结构类造成影响
* 缺点：难以增加具体的Element角色，增加一个就要在Visitor中实现一个对应方法；Visitor工作需要Element角色公开足够多的信息，公开少了不能工作，公开多了很难对数据结构改良

